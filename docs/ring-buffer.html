
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    
    <meta name="description" content="Ring buffer data structure">
    <meta name="keywords" content="learn, explain, tutorial, data structures, algorithms, graph, tree, interview, java, golang, kotlin, python, javascript, ring buffer">

    <title>  Ring buffer data structure | Practical algorithms and data structures </title>
    <link rel='stylesheet' href='/static/styles/styles.css'/>
    <link rel='stylesheet' href='/static/styles/prism.css'/>
</head>

<body>

<div class="rootContainer">

    <div class="horizontal-menu-box">
        
    <div class="menu">
    
    <div class="menuItem">
        
            <a href="/index.html" >
                ABOUT
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/fundamental.html" >
                FUNDAMENTAL
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/basic.html" >
                BASIC
            </a>
        
    </div>

     
     <div class="menuItem">
        
            <a href="/advanced.html" >
                ADVANCED
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/ninja.html" >
                NINJA
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/languages.html" >
                LANGUAGES
            </a>
        
    </div>

</div>

    </div>

    <div class="content">
         <h1>Queue</h1>

<h2>Contents</h2>

<hr />

<ul>
<li><a href="#description">Ring buffer description</a></li>
<li><a href="#practice">In practice</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#kotlin">Kotlin</a></li>
</ul>

<hr />

<p><div id="description"/></p>

<h2>Description</h2>

<p>see <a href="https://en.wikipedia.org/wiki/Circular_buffer">wiki page on Ring Buffer/Circular Buffer</a></p>

<p><div id="practice"/></p>

<h2>In Practice</h2>

<p>Used often as fast alternative to queue based on arrays.</p>

<p>Also used when you want to see last N records, like <code>top</code> command</p>

<p><div id="java"/></p>

<h2>Java</h2>

<pre><code class="language-java">package arrays;

import list.Queue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;

public class EvictingRingBuffer&lt;E&gt; implements Queue&lt;E&gt; {
    private final int maxSize;
    private final ArrayList&lt;E&gt; container;

    private int writeIdx = 0;
    private int readIdx = 0;
    private int count = 0;

    public EvictingRingBuffer(int maxSize) {
        this.maxSize = maxSize;

        container = new ArrayList(Arrays.asList(new Object[maxSize]));
    }

    @Override
    public void enqueue(E element) {
        container.set(writeIdx, element);
        writeIdx = increment(writeIdx);
        if (count == maxSize) {
            readIdx = writeIdx;
        } else {
            count++;
        }
    }

    @Override
    public E dequeue() throws NoSuchElementException {
        if (count == 0) throw new NoSuchElementException();

        E result = container.get(readIdx);

        readIdx = increment(readIdx);
        count--;

        return result;
    }

    public List&lt;E&gt; elements() {
        List&lt;E&gt; result = new ArrayList&lt;&gt;(maxSize);

        int curIdx = readIdx;
        for (int i = 0; i &lt; count; curIdx = increment(curIdx), i++) {
            result.add(container.get(curIdx));
        }
        return result;
    }

    private int increment(int idx) {
        return (idx + 1) % container.size();
    }

}

</code></pre>

<p><div id="go"/></p>

<h2>Go</h2>

<pre><code class="language-go">package arrays

type RingBuffer struct {
	container []interface{}
	readIdx   int
	writeIdx  int
	count     int
	max       int
}

func NewRingBuffer(maxSize int) *RingBuffer {
	buf := new(RingBuffer)
	buf.max = maxSize
	buf.container = make([]interface{}, buf.max)
	return buf
}

func (buf *RingBuffer) Dequeue() (elem interface{}, ok bool) {
	ok = true
	if buf.count == 0 {
		return nil, false
	}
	elem = buf.container[buf.readIdx]

	buf.readIdx = buf.nextIdx(buf.readIdx)
	buf.count--
	return
}

func (buf *RingBuffer) Enqueue(elem interface{}) {
	buf.container[buf.writeIdx] = elem
	buf.writeIdx = buf.nextIdx(buf.writeIdx)
	if buf.count == buf.max {
		buf.readIdx = buf.writeIdx
	} else {
		buf.count++
	}
}

func (buf *RingBuffer) Elements() (result []interface{}) {
	result = make([]interface{}, 0, buf.max)

	curReadIdx := buf.readIdx
	for i := 0; i &lt; buf.count; i++ {
		result = append(result, buf.container[curReadIdx])
		curReadIdx = buf.nextIdx(curReadIdx)
	}
	return
}

func (buf *RingBuffer) nextIdx(curIdx int) int {
	return (curIdx + 1) % buf.max
}

</code></pre>

<p><div id="python"/></p>

<h2>Python</h2>

<pre><code class="language-python">class RingBuffer:
    def __init__(self, input_capacity):
        self.max_size = input_capacity
        self.container = [None] * input_capacity
        self.count = 0
        self.read_idx = 0
        self.write_idx = 0

    def enqueue(self, in_element):
        self.container[self.write_idx] = in_element
        self.write_idx = self._next_idx(self.write_idx)
        if self.count == self.max_size:
            self.read_idx = self.write_idx
        else:
            self.count = self.count + 1

    def dequeue(self):
        result = self.container[self.read_idx]

        self.read_idx = self._next_idx(self.read_idx)
        self.count = self.count - 1

        return result

    def elements(self):
        result = []
        cur_idx = self.read_idx
        for i in range(0, self.count):
            result.append(self.container[cur_idx])
            cur_idx = self._next_idx(cur_idx)
        return result

    def _next_idx(self, cur_idx):
        return (cur_idx + 1) % self.max_size

</code></pre>

<p><div id="javascript"/></p>

<h2>JavaScript</h2>

<pre><code class="language-javascript">class RingBuffer {
  constructor(capacity) {   
    this.container = Array(capacity).fill({})
    this.readIdx = 0
    this.writeIdx = 0
    this.count = 0
    this.maxSize = capacity
  }

  enqueue(element) {
    this.container[this.writeIdx] = element
    this.writeIdx = this.nextIdx(this.writeIdx)
    if (this.count === this.maxSize) {
      this.readIdx = this.writeIdx
    } else {
      this.count++
    }
  }

  dequeue() {
    const result = this.container[this.readIdx]

    this.readIdx = this.nextIdx(this.readIdx)
    this.count--

    return result
  }

  elements() {
    const result = []
    let curIdx = this.readIdx 
    for (i = 0; i &lt; this.count; i++) {
      result.push(this.container[curIdx])
      curIdx = this.nextIdx(curIdx)
    }
    return result
  }

  nextIdx(idx) {
    return (idx + 1) % this.maxSize    
  }
}
</code></pre>

<p><div id="kotlin"/></p>

<h2>Kotlin</h2>

<pre><code class="language-kotlin">package arrays

class EvictingRingBuffer&lt;T&gt;(val maxSize: Int) {
    private val container: Array&lt;T&gt; = arrayOfNulls&lt;Any?&gt;(maxSize) as Array&lt;T&gt;
    private var elementsCount = 0
    private var writeIdx = 0
    private var readIdx = 0

    fun enqueue(element: T) {
        container[writeIdx] = element
        writeIdx = incrementIdx(writeIdx)
        if (elementsCount == maxSize) {
            readIdx = writeIdx
        } else {
            elementsCount++
        }
    }

    fun dequeue(): T {
        require(elementsCount &gt; 0) { &quot;buffer is empty&quot; }

        val element = container[readIdx]
        elementsCount--
        readIdx = incrementIdx(readIdx)

        return element
    }

    fun elements(): Array&lt;T&gt; {
        val result: Array&lt;T&gt; = arrayOfNulls&lt;Any?&gt;(elementsCount) as Array&lt;T&gt;
        var idx = readIdx
        for (i in 0 until elementsCount) {
            result[i] = container[idx]
            idx = incrementIdx(idx)
        }
        return result
    }

    private fun incrementIdx(idx: Int): Int {
        return (idx + 1) % maxSize
    }
}
</code></pre>
 
    </div>

</div>


<script src="/static/js/prism.js"></script>
</body>
</html>

