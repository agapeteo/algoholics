
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    
    <meta name="description" content="Validate multiple parentheses algorithm">
    <meta name="keywords" content="learn, explain, tutorial, data structures, algorithms, graph, tree, interview, java, golang, kotlin, python, validate multiple parentheses">

    <title>  Validate multiple parentheses algorithm  | Practical algorithms and data structures </title>
    <link rel='stylesheet' href='/static/styles/styles.css'/>
    <link rel='stylesheet' href='/static/styles/prism.css'/>
</head>

<body>

<div class="rootContainer">

    <div class="horizontal-menu-box">
        
    <div class="menu">
    
    <div class="menuItem">
        
            <a href="/index.html" >
                ABOUT
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/fundamental.html" >
                FUNDAMENTAL
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/basic.html" >
                BASIC
            </a>
        
    </div>

     
     <div class="menuItem">
        
            <a href="/advanced.html" >
                ADVANCED
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/ninja.html" >
                NINJA
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/languages.html" >
                LANGUAGES
            </a>
        
    </div>

</div>

    </div>

    <div class="content">
         <h1>Validate multiple parentheses</h1>

<h2>Contents</h2>

<hr />

<ul>
<li><a href="#description">Description</a></li>
<li><a href="#complexity">Complexity</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#kotlin">Kotlin</a></li>
</ul>

<hr />

<p><div id="description"/></p>

<h2>Description</h2>

<p>This algorithms uses <code>Stack</code> data structure and works as follows:</p>

<ul>
<li>for open parenthesis, like <code>(</code> or <code>{</code> etc, <strong>put</strong> to <code>Stack</code></li>
<li>for close parenthesis, like <code>)</code> or <code>}</code> etc, <strong>pop</strong> from <code>Stack</code>, but open parenthesis value should correspond to close parenthesis</li>
</ul>

<p>To avoid invalid cases like <code>)(</code> or <code>())(</code> check if stack is empty, if so - return <code>false</code></p>

<p>After checking each character return <code>true</code> if <code>Stack</code> is empty, otherwise return <code>false</code></p>

<p><div id="complexity"/></p>

<h2>Complexity</h2>

<p><code>O(N)</code></p>

<p><div id="java"/></p>

<h2>Java</h2>

<pre><code class="language-java">package list;

import java.util.*;

public class JavaMultipleParenthesesValidator {
    private final char[] openArr;
    private final char[] closeArr;

    /**
     * Parentheses for @param openArr and @param closeArr should be in the same order. f.e '{', '[' and '}', ']'
     */
    public JavaMultipleParenthesesValidator(char[] openArr, char[] closeArr) {
        this.openArr = openArr;
        this.closeArr = closeArr;
    }

    public boolean validate(String str) {
        if (str == null || str.isEmpty()) return false;

        Deque&lt;Character&gt; stack = new LinkedList&lt;&gt;();
        Map&lt;Character, Integer&gt; openChars = mapFor(openArr);
        Map&lt;Character, Integer&gt; closeChars = mapFor(closeArr);

        char[] chars = str.toCharArray();

        for (int i = 0; i &lt; chars.length; i++) {
            char curChar = chars[i];
            if (openChars.keySet().contains(curChar)) {
                stack.push(curChar);
            } else if (closeChars.keySet().contains(curChar)) {
                if (stack.isEmpty()) return false;

                Character topChar = stack.pop();
                // index for close char should correspond to open char in array of parentheses
                if (closeChars.get(curChar) != openChars.get(topChar)) {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }

    private Map&lt;Character, Integer&gt; mapFor(char[] chars) {
        Map&lt;Character, Integer&gt; result = new HashMap&lt;&gt;();

        for (int i = 0; i &lt; chars.length; i++) {
            result.put(chars[i], i);
        }
        return result;
    }

}

</code></pre>

<p>Test:</p>

<pre><code class="language-java">package list;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class JavaMultipleParenthesesValidatorTest {
    static char[] openChars = {'[', '{', '('};
    static char[] closeChars = {']', '}', ')'};

    @Test
    public void valid_same_parentheses() {
        // given
        JavaMultipleParenthesesValidator validator = new JavaMultipleParenthesesValidator(openChars, closeChars);

        // when
        boolean actual = validator.validate(&quot;to ((be)) or (not) to be&quot;);

        // then
        assertTrue(actual);
    }

    @Test
    public void valid_different_parentheses() {
        // given
        JavaMultipleParenthesesValidator validator = new JavaMultipleParenthesesValidator(openChars, closeChars);

        // when
        boolean actual = validator.validate(&quot;to ([be]) or {not} to be&quot;);

        // then
        assertTrue(actual);
    }

    @Test
    public void not_valid_different_parentheses() {
        // given
        JavaMultipleParenthesesValidator validator = new JavaMultipleParenthesesValidator(openChars, closeChars);

        // when
        boolean actual = validator.validate(&quot;to ( [be] {or} not }&quot;);

        // then
        assertFalse(actual);
    }

    @Test
    public void startsClosedShouldFail() {
        // given
        JavaMultipleParenthesesValidator validator = new JavaMultipleParenthesesValidator(openChars, closeChars);

        // when
        boolean actual = validator.validate(&quot;)(&quot;);

        // then
        assertFalse(actual);
    }

    @Test
    public void notValidClosedPositionInTheMiddle() {
        // given
        JavaMultipleParenthesesValidator validator = new JavaMultipleParenthesesValidator(openChars, closeChars);

        // when
        boolean actual = validator.validate(&quot;to (be) }{ or not&quot;);

        // then
        assertFalse(actual);
    }

}
</code></pre>

<p><div id="go"/></p>

<h2>Go</h2>

<pre><code class="language-go">package list

func validateMultiple(open []rune, close []rune, str string) bool {
	openChars := mapFor(open)
	closeChars := mapFor(close)
	var stack []rune

	runes := []rune(str)
	for _, c := range runes {
		_, isOpen := openChars[c]
		_, isClose := closeChars[c]

		if isOpen {
			stack = append(stack, c) // push
		} else if isClose {
			if len(stack) == 0 {
				return false
			}
			lastChar := stack[len(stack)-1]
			stack = stack[:len(stack)-1] // pop
			if closeChars[c] != openChars[lastChar] {
				return false
			}
		}
	}
	return len(stack) == 0
}

func mapFor(chars []rune) map[rune]int {
	m := make(map[rune]int)
	for i, c := range chars {
		m[c] = i
	}
	return m
}

</code></pre>

<p>Test:</p>

<pre><code class="language-go">package list

import &quot;testing&quot;

func Test_validateMultiple(t *testing.T) {
	open := []rune{'(', '{', '['}
	close := []rune{')', '}', ']'}

	type args struct {
		open  []rune
		close []rune
		str   string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{&quot;should be valid 1&quot;, args{open, close, &quot;to ((be)) or (not) to be&quot;}, true},
		{&quot;should be valid 2&quot;, args{open, close, &quot;to ([be]) or {not} to be&quot;}, true},
		{&quot;should not valid&quot;, args{open, close, &quot;to ( [be] {or} not }&quot;}, false},
		{&quot;should not valid, starts with close &quot;, args{open, close, &quot;)(&quot;}, false},
		{&quot;should not valid, not closing properly &quot;, args{open, close, &quot;to (be) }{ or not&quot;}, false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := validateMultiple(tt.args.open, tt.args.close, tt.args.str); got != tt.want {
				t.Errorf(&quot;validate() = %v, want %v&quot;, got, tt.want)
			}
		})
	}
}
</code></pre>

<p><div id="python"/></p>

<h2>Python</h2>

<pre><code class="language-python">def map_for(some_list):
    m = {}
    for i in range(len(some_list)):
        m[some_list[i]] = i
    return m


def validate(open_list, close_list, input_str):
    open_map = map_for(open_list)
    close_map = map_for(close_list)

    stack = []
    for each_char in input_str:
        if each_char in open_map:
            stack.append(each_char)
        elif each_char in close_map:
            if len(stack) == 0:
                return False
            top_char = stack.pop()
            if close_map[each_char] != open_map[top_char]:
                return False
    return len(stack) == 0


def test():
    open_list = [&quot;{&quot;, &quot;[&quot;, &quot;(&quot;]
    close_list = [&quot;}&quot;, &quot;]&quot;, &quot;)&quot;]

    assert (validate(open_list, close_list, &quot;to ((be)) or (not) to be&quot;)), &quot;should be valid&quot;
    assert (validate(open_list, close_list, &quot;to ([be]) or {not} to be&quot;)), &quot;should be valid&quot;
    assert (not validate(open_list, close_list, &quot;to ( [be] {or} not }&quot;)), &quot;should not be valid&quot;
    assert (not validate(open_list, close_list, &quot;)(&quot;)), &quot;should not be valid&quot;
    assert (not validate(open_list, close_list, &quot;to (be) }{ or not&quot;)), &quot;should not be valid&quot;


if __name__ == &quot;__main__&quot;:
    test()

</code></pre>

<p><div id="javascript"/></p>

<h2>JavaScript</h2>

<pre><code class="language-javascript">function mapFor(arr) {
  const map = new Map()
  for (i=0; i &lt; arr.length; i++) {
    map.set(arr[i], i)
  }
  return map
}

function validate(openArr, closedArr, str) {
  const openChars = mapFor(openArr)
  const closeChars = mapFor(closedArr)
  const stack = []

  for (i=0; i &lt; str.length; i++) {
    const curChar = str[i]
    if (openChars.has(curChar)) {
      stack.push(curChar)
    } else if (closeChars.has(curChar)) {
        if (stack.length == 0) return false

        const topChar = stack.pop()
        if (closeChars.get(curChar) != openChars.get(topChar)) {
          return false
        }
    }
  }
  return stack.length == 0
}

const openArr = [&quot;{&quot;, &quot;[&quot;, &quot;(&quot;]
const closeArr = [&quot;}&quot;, &quot;]&quot;, &quot;)&quot;]
console.log(validate(openArr, closeArr, &quot;to ((be)) or (not) to be&quot;)) // true
console.log(validate(openArr, closeArr, &quot;to ([be]) or {not} to be&quot;)) // true
console.log(validate(openArr, closeArr, &quot;to ( [be] {or} not }&quot;)) // false
console.log(validate(openArr, closeArr, &quot;)(&quot;)) // false
console.log(validate(openArr, closeArr, &quot;to (be) }{ or not&quot;)) // false
</code></pre>

<p><div id="kotlin"/></p>

<h2>Kotlin</h2>

<pre><code class="language-kotlin">package list

import java.util.*

class MultipleParenthesesValidator(val openArr: Array&lt;Char&gt;, val closeArr: Array&lt;Char&gt;) {

    fun validate(str: String): Boolean {
        if (str.isBlank()) return false;

        val closeChars = mapFor(closeArr)
        val openChars = mapFor(openArr)
        val stack: Deque&lt;Char&gt; = LinkedList()

        for (i in 0 until str.length) {
            val curChar = str[i]
            if (openChars.contains(curChar)) {
                stack.push(curChar)
            } else if (closeChars.contains(curChar)) {
                if (stack.isEmpty()) return false

                val topChar = stack.pop()
                if (closeChars[curChar] != openChars[topChar]) {
                    return false
                }
            }
        }
        return stack.isEmpty()
    }

    private fun mapFor(chars: Array&lt;Char&gt;): Map&lt;Char, Int&gt; {
        val result = hashMapOf&lt;Char, Int&gt;()
        for ((idx, c) in chars.withIndex()) {
            result[c] = idx
        }

        return result
    }
}
</code></pre>

<p>Test:</p>

<pre><code class="language-kotlin">package list

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

internal class MultipleParenthesesValidatorTest {
    private val openChars = arrayOf('[', '{', '(')
    private val closeChars = arrayOf(']', '}', ')')

    @Test
    fun `valid with same parentheses`() {
        // given
        val validator = MultipleParenthesesValidator(openChars, closeChars)

        // when
        val actual = validator.validate(&quot;to ((be)) or (not) to be&quot;)

        // then
        assertTrue(actual)
    }

    @Test
    fun `valid different parentheses`() {
        // given
        val validator = MultipleParenthesesValidator(openChars, closeChars)

        // when
        val actual = validator.validate(&quot;to ([be]) or {not} to be&quot;)

        // then
        assertTrue(actual)
    }

    @Test
    fun `not valid different parentheses`() {
        // given
        val validator = MultipleParenthesesValidator(openChars, closeChars)

        // when
        val actual = validator.validate(&quot;to ( [be] {or} not }&quot;)

        // then
        assertFalse(actual)
    }

    @Test
    fun `starts closed should fail`() {
        // given
        val validator = MultipleParenthesesValidator(openChars, closeChars)

        // when
        val actual = validator.validate(&quot;)(&quot;)

        // then
        assertFalse(actual)
    }

    @Test
    fun `not valid closed position in the middle`() {
        // given
        val validator = MultipleParenthesesValidator(openChars, closeChars)

        // when
        val actual = validator.validate(&quot;to (be) }{ or not&quot;)

        // then
        assertFalse(actual)
    }
}

</code></pre>
 
    </div>

</div>


<script src="/static/js/prism.js"></script>
</body>
</html>

