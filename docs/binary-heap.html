
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    
    <meta name="description" content="Binary heap data structure">
    <meta name="keywords" content="learn, explain, tutorial, data structures, algorithms, graph, tree, interview, java, golang, kotlin, python, binary heap, tree, priority queue">

    <title>  Binary heap data structure  | Practical algorithms and data structures </title>
    <link rel='stylesheet' href='/static/styles/styles.css'/>
    <link rel='stylesheet' href='/static/styles/prism.css'/>
</head>

<body>

<div class="rootContainer">

    <div class="horizontal-menu-box">
        
    <div class="menu">
    
    <div class="menuItem">
        
            <a href="/index.html" >
                ABOUT
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/fundamental.html" >
                FUNDAMENTAL
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/basic.html" >
                BASIC
            </a>
        
    </div>

     
     <div class="menuItem">
        
            <a href="/advanced.html" >
                ADVANCED
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/ninja.html" >
                NINJA
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/languages.html" >
                LANGUAGES
            </a>
        
    </div>

</div>

    </div>

    <div class="content">
         <h1>Binary heap</h1>

<h2>Contents</h2>

<hr />

<ul>
<li><a href="#description">Binary heap description</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#kotlin">Kotlin</a></li>
</ul>

<hr />

<p><div id="description" /></p>

<h2>Binary heap</h2>

<ul>
<li><p>push - <code>O log(N)</code></p></li>

<li><p>pop (get and delete maximum/minimum) - <code>O log(N)</code></p></li>

<li><p>peek (get maximum/minimum) - <code>O(1)</code></p></li>
</ul>

<p><div id="java"/></p>

<h2>Java</h2>

<p>interface:</p>

<pre><code class="language-java">package tree;

import java.util.Collection;

public interface Heap&lt;E extends Comparable&lt;E&gt;&gt; {
    E peak();

    E pop();

    void push(E element);

    int size();

    Collection&lt;E&gt; elements();

}
</code></pre>

<p>implementation:</p>

<pre><code class="language-java">package tree;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class MaxBinaryHeap&lt;E extends Comparable&lt;E&gt;&gt; implements Heap&lt;E&gt; {
    private final List&lt;E&gt; container;

    public MaxBinaryHeap() {
        container = new ArrayList&lt;&gt;();
    }

    @Override
    public E peak() {
        return container.size() &gt; 0 ? container.get(container.size() - 1) : null;
    }

    @Override
    public E pop() {
        if (container.isEmpty()) return null;

        if (container.size() == 1) {
            return container.remove(0);
        }

        E result = container.get(0);
        E latest = container.get(container.size() - 1);
        container.remove(container.size() - 1);
        container.set(0, latest);

        siftDown(0);

        return result;
    }

    private void siftDown(int idx) {
        if (idx &lt; 0 || idx &gt;= container.size() / 2) return;

        int leftIdx = leftChildIdx(idx);
        int rightIdx = rightChildIdx(idx);

        int largerChildIdx;
        if (rightIdx &lt; container.size() &amp;&amp; container.get(rightIdx).compareTo(container.get(leftIdx)) &gt; 0) {
            largerChildIdx = rightIdx;
        } else {
            largerChildIdx = leftIdx;
        }

        if (container.get(largerChildIdx).compareTo(container.get(idx)) &gt; 0) {
            swap(idx, largerChildIdx);
            siftDown(largerChildIdx);
        }
    }

    @Override
    public void push(E element) {
        if (element == null) {
            throw new IllegalArgumentException(&quot;null values are not valid elements&quot;);
        }
        container.add(element);
        siftUp(container.size() - 1);
    }

    private void siftUp(int idx) {
        if (idx &lt;= 0) return;

        int parentIdx = parentIdx(idx);
        if (container.get(idx).compareTo(container.get(parentIdx)) &gt; 0) {
            swap(idx, parentIdx);
            siftUp(parentIdx);
        }
    }

    private void swap(int i, int j) {
        E tmp = container.get(i);
        container.set(i, container.get(j));
        container.set(j, tmp);
    }

    @Override
    public int size() {
        return container.size();
    }

    @Override
    public Collection&lt;E&gt; elements() {
        List&lt;E&gt; result = new ArrayList&lt;&gt;(container.size());
        result.addAll(container);
        return result;
    }

    private int parentIdx(int idx) {
        return (idx - 1) / 2;
    }

    private int leftChildIdx(int idx) {
        return idx * 2 + 1;
    }

    private int rightChildIdx(int idx) {
        return idx * 2 + 2;
    }
}
</code></pre>

<p><div id="go"/></p>

<h2>Go</h2>

<pre><code class="language-go">package tree

import &quot;errors&quot;

var NoSuchElementError = errors.New(&quot;no such element&quot;)

type MaxHeap struct {
	elm []int
}

func (H *MaxHeap) Peak() (int, error) {
	if len(H.elm) == 0 {
		return -1, NoSuchElementError
	}
	return H.elm[0], nil
}

func (H *MaxHeap) Pop() (int, error) {
	if len(H.elm) == 0 {
		return -1, NoSuchElementError
	}

	var result = H.elm[0]

	if len(H.elm) == 1 {
		H.elm = make([]int, 0)
		return result, nil
	}

	H.elm[0] = H.elm[len(H.elm)-1] // put last to first
	H.elm = H.elm[:len(H.elm)-1]   // trim last element in slice

	siftDown(0, H.elm)

	return result, nil
}

func siftDown(i int, e []int) {
	if i &lt; 0 || i &gt;= len(e)/2 {
		return // no need to sift down leaf elements
	}

	var l = leftChildIdx(i)
	var r = rightChildIdx(i)

	var largerChild = l
	if r &lt; len(e) &amp;&amp; e[r] &gt; e[l] {
		largerChild = r
	}

	if e[largerChild] &gt; e[i] {
		swap(i, largerChild, e)
		siftDown(largerChild, e)
	}
}

func (H *MaxHeap) Push(v int) {
	if len(H.elm) == 0 {
		H.elm = append(H.elm, v)
		return
	}

	H.elm = append(H.elm, v)

	siftUp(len(H.elm)-1, H.elm)
}

func siftUp(i int, e []int) {
	if i &lt;= 0 {
		return
	}
	var p = parentIdx(i)

	if e[i] &gt; e[p] {
		swap(i, p, e)
		siftUp(p, e)
	}
}

func swap(i int, j int, e []int) {
	e[i], e[j] = e[j], e[i]
}

func (H *MaxHeap) Elements() []int {
	var result = make([]int, len(H.elm))
	copy(result, H.elm)
	return result
}

func (H *MaxHeap) Size() int {
	return len(H.elm)
}

func leftChildIdx(i int) int {
	return i*2 + 1
}

func rightChildIdx(i int) int {
	return i*2 + 2
}

func parentIdx(i int) int {
	return (i - 1) / 2
}
</code></pre>

<p><div id="python"/></p>

<h2>Python</h2>

<pre><code class="language-python">class Heap:
    def __init__(self):
        self.container = []

    def peek(self):
        if len(self.container) == 0:
            return None
        return self.container[0]

    def pop(self):
        if len(self.container) == 0:
            return None

        if len(self.container) == 1:
            return self.container.pop(0)

        result = self.container[0]
        last = self.container.pop()
        self.container[0] = last
        self._sift_down(0)
        return result

    def push(self, element):
        self.container.append(element)
        self._sift_up(len(self.container) - 1)

    def __len__(self):
        return len(self.container)

    def _sift_up(self, idx):
        if idx == 0:
            return
        parent_idx = self.parent_idx(idx)
        if self.container[idx] &gt; self.container[parent_idx]:
            self._swap(idx, parent_idx)
            self._sift_up(parent_idx)

    def _sift_down(self, idx):
        if idx &gt;= len(self.container) // 2:
            return

        right_child_idx = self.right_child_idx(idx)
        left_child_idx = self.left_child_idx(idx)
        greater_child_idx = left_child_idx

        if right_child_idx &lt; len(self.container) and self.container[right_child_idx] &gt; self.container[left_child_idx]:
            greater_child_idx = right_child_idx

        if self.container[greater_child_idx] &gt; self.container[idx]:
            self._swap(idx, greater_child_idx)
            self._sift_down(greater_child_idx)

    def _swap(self, i, j):
        self.container[i], self.container[j] = self.container[j], self.container[i]

    @staticmethod
    def parent_idx(idx):
        return (idx - 1) // 2

    @staticmethod
    def left_child_idx(idx):
        return idx * 2 + 1

    @staticmethod
    def right_child_idx(idx):
        return idx * 2 + 2
</code></pre>

<p><div id="javascript"/></p>

<h2>JavaScript</h2>

<pre><code class="language-javascript">class MaxBinaryHeap {
    constructor() {
        this.container = [];
    }

    size() {
        return this.container.length;
    }

    peek() {
        if (this.container.length == 0) {
            return undefined;
        }
        return this.container[0];
    }

    push(element) {
        this.container.push(element);
        this.siftUp(this.container.length - 1);
    }

    pop() {
        if (this.container.length == 0) {
            return undefined;
        }
        if (this.container.length == 1) {
            return this.container.pop();
        }
        const result = this.container[0];
        const last = this.container.pop();
        this.container[0] = last;
        this.siftDown(0);

        return result;
    }

    siftUp(idx) {
        if (idx == 0) return;

        const parentIdx = MaxBinaryHeap.parentIdx(idx);
        if (this.container[idx] &gt; this.container[parentIdx]) {
            this.swap(idx, parentIdx);
            this.siftUp(parentIdx);
        }
    }

    siftDown(idx) {
        if (idx &gt;= Math.floor(this.container.length / 2)) {
            return
        }
        const leftChildIdx = MaxBinaryHeap.leftChildIdx(idx);
        const rightChildIdx = MaxBinaryHeap.rightChildIdx(idx);
        let greaterChildIdx = leftChildIdx;
        if (rightChildIdx &lt; this.container.length &amp;&amp; this.container[rightChildIdx] &gt; this.container[leftChildIdx]) {
            greaterChildIdx = rightChildIdx;
        }
        if (this.container[greaterChildIdx] &gt; this.container[idx]) {
            this.swap(greaterChildIdx, idx);
            this.siftDown(greaterChildIdx);
        }
    }

    swap(i, j) {
        [this.container[i], this.container[j]] = [this.container[j], this.container[i]]
    }

    static parentIdx(idx) {
        return Math.floor((idx - 1) / 2)
    }

    static rightChildIdx(idx) {
        return idx * 2 + 2
    }

    static leftChildIdx(idx) {
        return idx * 2 + 1
    }
}
</code></pre>

<p><div id="kotlin"/></p>

<h2>Kotlin</h2>

<p>interface:</p>

<pre><code class="language-kotlin">package tree

interface Heap&lt;E : Comparable&lt;E&gt;&gt; {

    fun peek(): E
    fun pop(): E
    fun push(value: E)

    fun elements(): List&lt;E&gt;
    fun size(): Int
}
</code></pre>

<p>implementation:</p>

<pre><code class="language-kotlin"> package tree
 
 class BinaryHeap&lt;E : Comparable&lt;E&gt;&gt; : Heap&lt;E&gt; {
 
     private val elements = mutableListOf&lt;E&gt;()
 
     override fun size(): Int {
         return elements.size
     }
 
     override fun peek(): E {
         assert (elements.isNotEmpty() ) { &quot;heap is empty&quot; }
         return elements[0]
     }
 
     override fun pop(): E {
         assert (elements.isNotEmpty() ) { &quot;heap is empty&quot; }
 
         if (elements.size == 1){
             return elements.removeAt(0)
         }
 
         val result = elements[0]
         val latest = elements.removeAt(elements.size - 1)
         elements[0] = latest
 
         siftDown(0)
 
         return result
     }
 
     private fun siftDown(idx: Int) {
         if (idx &lt; 0 || idx &gt;= elements.size/2) return
 
         val leftIdx = leftChildIdx(idx)
         val rightIdx = rightChildIdx(idx)
 
         val largerChildIdx = if (rightIdx &lt; elements.size &amp;&amp; elements[rightIdx] &gt; elements[leftIdx]) {
             rightIdx
         } else {
             leftIdx
         }
 
         if (elements[largerChildIdx] &gt; elements[idx]){
             swap(idx, largerChildIdx)
             siftDown(largerChildIdx)
         }
     }
 
     override fun push(value: E) {
         elements.add(value)
 
         siftUp(elements.size - 1)
     }
 
     private fun siftUp(idx: Int) {
         if (idx &lt;= 0) return
 
         val parentIdx = parentIdx(idx)
 
         if (elements[idx] &gt; elements[parentIdx]){
             swap(idx, parentIdx)
             siftUp(parentIdx)
         }
     }
 
     override fun elements(): List&lt;E&gt; {
         val result = mutableListOf&lt;E&gt;()
 
         result.addAll(elements)
 
         return result
     }
 
     private fun swap(idxI: Int, idxJ: Int){
         val tmp: E = elements[idxI]
         elements[idxI] = elements[idxJ]
         elements[idxJ] = tmp
     }
 
     private fun leftChildIdx(idx: Int): Int = idx * 2 + 1
     private fun rightChildIdx(idx: Int): Int = idx * 2 + 2
     private fun parentIdx(idx: Int): Int = (idx - 1) / 2
 }
</code></pre>
 
    </div>

</div>


<script src="/static/js/prism.js"></script>
</body>
</html>

