
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    
    <meta name="description" content="Binary search tree data structure">
    <meta name="keywords" content="learn, explain, tutorial, data structures, algorithms, graph, tree, interview, java, golang, kotlin, python, graph">

    <title>  Graph data structure  | Practical algorithms and data structures </title>
    <link rel='stylesheet' href='/static/styles/styles.css'/>
    <link rel='stylesheet' href='/static/styles/prism.css'/>
</head>

<body>

<div class="rootContainer">

    <div class="horizontal-menu-box">
        
    <div class="menu">
    
    <div class="menuItem">
        
            <a href="/index.html" >
                ABOUT
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/fundamental.html" >
                FUNDAMENTAL
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/basic.html" >
                BASIC
            </a>
        
    </div>

     
     <div class="menuItem">
        
            <a href="/advanced.html" >
                ADVANCED
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/ninja.html" >
                NINJA
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/languages.html" >
                LANGUAGES
            </a>
        
    </div>

</div>

    </div>

    <div class="content">
         <h1>Graph</h1>

<h2>Contents</h2>

<hr />

<ul>
<li><a href="#description">Description</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#kotlin">Kotlin</a></li>
</ul>

<hr />

<p><div id="description" /></p>

<h2>Description</h2>

<blockquote>
<p><code>TODO description</code></p>
</blockquote>

<p><div id="java"/></p>

<h2>Java</h2>

<pre><code class="language-java">package graph;

import java.util.*;

public class Graph&lt;E&gt; {
    private final Map&lt;E, Set&lt;E&gt;&gt; edges;

    public Graph() {
        edges = new HashMap&lt;&gt;();
    }

    void addBothEdges(E from, E to) {
        addEdge(from, to);
        addEdge(to, from);
    }

    private void addEdge(E from, E to) {
        Set&lt;E&gt; currentEdges = edges.get(from);
        if (currentEdges == null) {
            currentEdges = new HashSet&lt;&gt;();
            edges.put(from, currentEdges);
        }
        currentEdges.add(to);
    }

    public List&lt;E&gt; elementsDfs() {
        List&lt;E&gt; resultList = new ArrayList&lt;&gt;();
        Set&lt;E&gt; visited = new HashSet&lt;&gt;();
        edges.keySet().forEach(v -&gt; elementsDfs(v, resultList, visited));
        return resultList;
    }

    private void elementsDfs(E vertex, List&lt;E&gt; resultList, Set&lt;E&gt; visited) {
        if (visited.contains(vertex)) return;

        resultList.add(vertex);
        visited.add(vertex);

        edges.get(vertex).forEach(v -&gt; elementsDfs(v, resultList, visited));
    }

    public List&lt;E&gt; elementsBfs() {
        List&lt;E&gt; resultList = new ArrayList&lt;&gt;();
        Set&lt;E&gt; visited = new HashSet&lt;&gt;();
        edges.keySet().forEach(v -&gt; elementsBfs(v, resultList, visited));
        return resultList;
    }

    private void elementsBfs(E vertex, List&lt;E&gt; resultList, Set&lt;E&gt; visited) {
        Deque&lt;E&gt; queue = new LinkedList&lt;&gt;();
        queue.add(vertex);

        while (!queue.isEmpty()) {
            E eachVertex = queue.pollFirst();

            if (visited.contains(eachVertex)) continue;

            resultList.add(eachVertex);
            visited.add(eachVertex);

            edges.get(eachVertex).forEach(v -&gt; queue.add(v));
        }
    }

    public boolean connected(E start, E target) {
        Set&lt;E&gt; visited = new HashSet&lt;&gt;();
        return connectedFromNode(start, target, visited);
    }

    private boolean connectedFromNode(E start, E target, Set&lt;E&gt; visited) {
        if (visited.contains(start)) return false;

        if (start == target) return true;

        visited.add(start);

        for (E vertex: edges.get(start)) {
            if (connectedFromNode(vertex, target, visited)) return true;
        }

        return false;
    }
}

</code></pre>

<p><div id="go"/></p>

<h2>Go</h2>

<pre><code class="language-go">package graph

type Graph struct {
	edges map[interface{}][]interface{}
}

func NewGraph() *Graph {
	g := new(Graph)
	g.edges = make(map[interface{}][]interface{})
	return g
}

func (g Graph) AddEdge(from interface{}, to interface{}) {
	edges := g.edges[from]
	newEdges := append(edges, to)
	g.edges[from] = newEdges
}

func (g Graph) AddBothEdges(from interface{}, to interface{}) {
	g.AddEdge(from, to)
	g.AddEdge(to, from)
}

func (g Graph) ElementsDfs() []interface{} {
	visited := make(map[interface{}]struct{})
	result := make([]interface{}, 0)

	for k, _ := range g.edges {
		g.appendElementsDfs(k, &amp;visited, &amp;result)
	}
	return result
}

func (g Graph) IsConnected(from interface{}, to interface{}) bool {
	visited := make(map[interface{}]struct{})
	return g.isConnectedFrom(from, to, visited)
}

func (g Graph) isConnectedFrom(from interface{}, to interface{}, visited map[interface{}]struct{}) bool {
	_, isVisited := visited[from];
	if isVisited {
		return false
	}

	if from == to {
		return true
	}

	visited[from] = struct{}{}

	for _, conn := range g.edges[from] {
		if g.isConnectedFrom(conn, to, visited) {
			return true
		}
	}
	return false
}

func (g Graph) ElementsBfs() []interface{} {
	visited := make(map[interface{}]struct{})
	result := make([]interface{}, 0)

	for k, _ := range g.edges {
		queue := make([]interface{}, 0)
		queue = append(queue, k)

		for len(queue) &gt; 0 {
			first := queue[0]
			queue = queue[1:]

			_, isVisited := visited[k];
			if isVisited {
				continue
			}
			result = append(result, first)
			visited[first] = struct{}{}

			for _, e := range g.edges[first] {
				queue = append(queue, e)
			}
		}
	}
	return result
}

func (g Graph) appendElementsDfs(from interface{}, visited *map[interface{}]struct{}, list *[]interface{}) {
	if _, isVisited := (*visited)[from]; isVisited {
		return
	}
	*list = append(*list, from)
	(*visited)[from] = struct{}{}

	for _, v := range g.edges[from] {
		g.appendElementsDfs(v, visited, list)
	}
}
</code></pre>

<p><div id="python"/></p>

<h2>Python</h2>

<pre><code class="language-python">class Graph:
    def __init__(self):
        self.edges = {}

    def add_edge(self, input_from, input_to):
        connections = self.edges.get(input_from)

        if not connections:
            connections = set()
        connections.add(input_to)

        self.edges[input_from] = connections

    def add_both_edges(self, input_from, input_to):
        self.add_edge(input_from, input_to)
        self.add_edge(input_to, input_from)

    def elements_dfs(self):
        result_list = []
        visited = set()

        for element in self.edges.keys():
            self.add_dfs_elements(element, result_list, visited)

        return result_list

    def add_dfs_elements(self, from_element, result_list, visited):
        if from_element in visited:
            return

        result_list.append(from_element)
        visited.add(from_element)

        for e in self.edges[from_element]:
            self.add_dfs_elements(e, result_list, visited)

    def elements_bfs(self):
        visited = set()
        result_list = []

        for k in self.edges.keys():
            queue = [k]
            while len(queue) &gt; 0:
                first_element = queue.pop(0)
                if first_element in visited:
                    continue
                result_list.append(first_element)
                visited.add(first_element)

                for vertex in self.edges[first_element]:
                    queue.append(vertex)
        return result_list

    def is_connected(self, from_element, to_element):
        return self._is_connected(from_element, to_element, set())

    def _is_connected(self, from_element, to_element, visited):
        if from_element in visited:
            return False

        if from_element == to_element:
            return True

        visited.add(from_element)

        for vertex in self.edges[from_element]:
            if self._is_connected(vertex, to_element, visited):
                return True

        return False
</code></pre>

<p><div id="javascript"/></p>

<h2>JavaScript</h2>

<pre><code class="language-javascript">class Graph {
  constructor() {
    this.edges = new Map()
    this.elementsDfs=this.elementsDfs.bind(this)
  }

  addEdge(from_element, to_element) {
    let connections = this.edges[from_element]
    if (!connections) {
      connections = []
    }
    connections.push(to_element)

    this.edges[from_element] = connections
  }

  addBothEdges(from_element, to_element) {
    this.addEdge(from_element, to_element)
    this.addEdge(to_element, from_element)
  }

  elementsDfs() {
    const visited = new Set()
    const result = []
   
    for (const key in this.edges) {       
      this.addElementsDfsFrom(key, visited, result)
    } 
    return result
  }

  addElementsDfsFrom(from_element, visited, result) {    
    if (visited.has(from_element)) return

    result.push(from_element)
    visited.add(from_element)

    for (const k of this.edges[from_element]) {
      this.addElementsDfsFrom(k, visited, result)
    }
  }

  elementsBfs() {
    const visited = new Set()
    const result = []
   
    for (const key in this.edges) {       
      const queue = []
      queue.push(key)
      while (queue.length &gt; 0) {
        first = queue.shift()
        if (visited.has(first)) continue
        result.push(first)
        visited.add(first)
        for (const k of this.edges[first]) {
          queue.push(k)
        }
      }
    } 
    return result
  }

  isConnected(fromElement, toElement) {
    const visited = new Set()
    return this.isConnectedFrom(fromElement, toElement, visited)
  }

  isConnectedFrom(fromElement, toElement, visited) {
    if (visited.has(fromElement)) return false

    if (fromElement == toElement) return true
    
    visited.add(fromElement)

    for (vertex of this.edges[fromElement]) {      
      if (this.isConnectedFrom(vertex, toElement, visited)) {
        return true
      }
    }
    return false
  }
}
</code></pre>

<p><div id="kotlin"/></p>

<h2>Kotlin</h2>

<pre><code class="language-kotlin">package graph

import java.util.*
import kotlin.collections.HashSet


class Graph&lt;E&gt; {

    val edges: MutableMap&lt;E, HashSet&lt;E&gt;&gt; = mutableMapOf()

    fun addEdge(from: E, to: E) {
        edges.computeIfAbsent(from) { HashSet() }.add(to)
    }

    fun addBothEdges(from: E, to: E) {
        addEdge(from, to)
        addEdge(to, from)
    }

    fun elementsDfs(): List&lt;E&gt; {
        val visited = mutableSetOf&lt;E&gt;()

        fun addToResult(element: E, list: MutableList&lt;E&gt;) {
            if (visited.contains(element)) return

            visited.add(element)
            list.add(element)
            edges[element]?.forEach { addToResult(it, list) }
        }

        val result = mutableListOf&lt;E&gt;()
        edges.keys.forEach { addToResult(it, result) }
        return result
    }

    fun elementsBfs(): List&lt;E&gt; {
        val result = mutableListOf&lt;E&gt;()
        val visited = mutableSetOf&lt;E&gt;()

        edges.keys.forEach { topElement -&gt;
            val queue: Deque&lt;E&gt; = LinkedList()

            queue.add(topElement)
            while (queue.isNotEmpty()) {
                val element = queue.removeFirst()
                if (!visited.contains(element)) {
                    visited.add(element)
                    result.add(element)
                    edges[element]?.forEach { queue.add(it) }
                }
            }
        }
        return result
    }

    fun connected(from: E, to: E): Boolean { // using bfs
        if (from == to) return true

        val alreadyVisited = mutableSetOf&lt;E&gt;().apply { add(from) }
        val queue: Deque&lt;E&gt; = LinkedList()

        edges[from]?.forEach { queue.add(it) }

        while (queue.isNotEmpty()) {
            val element = queue.removeFirst()

            if (element == to) return true

            if (!alreadyVisited.contains(element)) {
                alreadyVisited.add(element)
                edges[element]?.forEach { queue.add(it) }
            }
        }
        return false
    }
}

</code></pre>
 
    </div>

</div>


<script src="/static/js/prism.js"></script>
</body>
</html>

