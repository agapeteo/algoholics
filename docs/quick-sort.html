
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    
    <meta name="description" content="Quick sort algorithm">
    <meta name="keywords" content="learn, explain, tutorial, data structures, algorithms, graph, tree, interview, java, golang, kotlin, python, sorting, quick sort">

    <title>  Quick sort algorithm  | Practical algorithms and data structures </title>
    <link rel='stylesheet' href='/static/styles/styles.css'/>
    <link rel='stylesheet' href='/static/styles/prism.css'/>
</head>

<body>

<div class="rootContainer">

    <div class="horizontal-menu-box">
        
    <div class="menu">
    
    <div class="menuItem">
        
            <a href="/index.html" >
                ABOUT
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/fundamental.html" >
                FUNDAMENTAL
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/basic.html" >
                BASIC
            </a>
        
    </div>

     
     <div class="menuItem">
        
            <a href="/advanced.html" >
                ADVANCED
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/ninja.html" >
                NINJA
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/languages.html" >
                LANGUAGES
            </a>
        
    </div>

</div>

    </div>

    <div class="content">
         <h1>Quick sort</h1>

<h2>Contents</h2>

<hr />

<ul>
<li><a href="#description">Description</a></li>
<li><a href="#complexity">Complexity</a></li>
<li><a href="#practice">In practice</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#kotlin">Kotlin</a></li>
</ul>

<hr />

<p><div id="description"/></p>

<h2>Description</h2>

<p>Not stable</p>

<p>Very popular and really fast sorting algorithm</p>

<p>More details on <a href="https://en.wikipedia.org/wiki/Quicksort">wikipedia on Quick sort</a></p>

<p>2 approaches:</p>

<ul>
<li><a href="https://upload.wikimedia.org/wikipedia/commons/8/84/Lomuto_animated.gif">Lomuto</a></li>
<li>Hoare</li>
</ul>

<p>Hoare&rsquo;s approach is used more often in practice than Lomuto&rsquo;s because it causes less swaps.
But Hoare&rsquo;s approach is very very error prone. It&rsquo;s easy to get into infinite loop or incorrectly treat duplicate values, especially last swap</p>

<p>see more details about <a href="https://cs.stackexchange.com/questions/11458/quicksort-partitioning-hoare-vs-lomuto">Hoare vs Lomuto</a></p>

<p>Other optimization:</p>

<ul>
<li>using insertion sort for small array ranges, f.e. less than 20</li>
<li>choosing pivot as median in sort range</li>
<li>3-way partition - partition array range into 3 parts: less than pivot, equal to pivot and more than pivot</li>
</ul>

<p><div id="complexity"/></p>

<h2>Complexity</h2>

<p><code>O(N log(N))</code></p>

<p>Worst case - <code>O(N^2)</code></p>

<p><div id="practice"/></p>

<h2>In practice</h2>

<p><code>Quick sort</code> is very popular and often used in practice for primitive types</p>

<p><div id="java"/></p>

<h2>Java</h2>

<p>Lomuto:</p>

<pre><code class="language-java">package sort;

public class LomutoQuickSort {

    public static void sort(int[] array) {
        if (array == null || array.length &lt; 2) return;

        sort(array, 0, array.length - 1);
    }

    private static void sort(int[] array, int lowIdx, int highIdx) {
        if (lowIdx &gt;= highIdx) return;

        int partitionIdx = partition(array, lowIdx, highIdx);
        sort(array, lowIdx, partitionIdx - 1);
        sort(array, partitionIdx + 1, highIdx);
    }

    private static int partition(int[] array, int lowIdx, int highIdx) {
        int pivotValue = array[highIdx];
        int i = lowIdx;
        int j = i;

        while (j &lt; highIdx) {
            if (array[j] &lt;= pivotValue) {
                swap(array, i, j);
                i++;
            }
            j++;
        }
        swap(array, highIdx, i);
        return i;
    }

    private static void swap(int[] array, int i, int j) {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
</code></pre>

<p>Hoare (simplified version from Sedgewick&rsquo;s book):</p>

<pre><code class="language-java">package sort;

public class HoareQuickSort {

    public static void sort(int[] array) {
        sort(array, 0, array.length - 1);
    }

    private static void sort(int[] array, int lowIdx, int highIdx) {
        if (lowIdx &gt;= highIdx) return;

        int partitionIdx = partition(array, lowIdx, highIdx);
        sort(array, lowIdx, partitionIdx - 1);
        sort(array, partitionIdx + 1, highIdx);
    }

    private static int partition(int[] array, int lowIdx, int highIdx) {
        int pivotValue = array[lowIdx];
        int leftIdx = lowIdx;
        int rightIdx = highIdx + 1;

        while (true) {
            do {
                leftIdx++;
                if (leftIdx == highIdx) break;
            } while (array[leftIdx] &lt; pivotValue);

            do {
                rightIdx--;
                if (rightIdx == lowIdx) break;
            } while (array[rightIdx] &gt; pivotValue);

            if (leftIdx &gt;= rightIdx) break;

            swap(array, leftIdx, rightIdx);
        }
        swap(array, lowIdx, rightIdx); // put pivot value to final pivot index
        return rightIdx;
    }

    private static void swap(int[] array, int leftIdx, int rightIdx) {
        int tmpValue = array[leftIdx];
        array[leftIdx] = array[rightIdx];
        array[rightIdx] = tmpValue;
    }
}

</code></pre>

<p><div id="go"/></p>

<h2>Go</h2>

<pre><code class="language-go">package sort

type QuickSortingStrategy int

const (
	Lomuto QuickSortingStrategy = iota
	Hoare
)

var PickedQuickSortStrategy = Lomuto

func QuickSort(arr []int) {
	if arr == nil || len(arr) &lt; 2 {
		return
	}
	quickSortRange(arr, 0, len(arr)-1)
}

func quickSortRange(arr []int, lowIdx, highIdx int) {
	if lowIdx &gt;= highIdx {
		return
	}

	var partitionIdx = -1

	if PickedQuickSortStrategy == Lomuto {
		partitionIdx = partitionLomuto(arr, lowIdx, highIdx)
	}
	if PickedQuickSortStrategy == Hoare {
		partitionIdx = partitionHoare(arr, lowIdx, highIdx)
	}
	if partitionIdx == -1 {
		panic(&quot;PickedQuickSortStrategy not defined&quot;)
	}

	quickSortRange(arr, lowIdx, partitionIdx-1)
	quickSortRange(arr, partitionIdx+1, highIdx)
}

func partitionLomuto(arr []int, lowIdx, highIdx int) int {
	pivot := arr[highIdx]
	i := lowIdx

	for j := lowIdx; j &lt; highIdx; j++ {
		if arr[j] &lt;= pivot {
			arr[i], arr[j] = arr[j], arr[i]
			i++
		}
	}
	arr[highIdx], arr[i] = arr[i], arr[highIdx]
	return i
}

func partitionHoare(arr []int, lowIdx, highIdx int) int {
	pivot := arr[lowIdx]
	leftIdx := lowIdx
	rightIdx := highIdx + 1

	for {
		for {
			leftIdx++
			if leftIdx == highIdx || arr[leftIdx] &gt;= pivot {
				break
			}
		}
		for {
			rightIdx--
			if  rightIdx == lowIdx || arr[rightIdx] &lt;= pivot{
				break
			}
		}
		if leftIdx &gt;= rightIdx {
			break
		}
		arr[leftIdx], arr[rightIdx] = arr[rightIdx], arr[leftIdx]
	}
	arr[rightIdx], arr[lowIdx] = arr[lowIdx], arr[rightIdx]
	return rightIdx
}

</code></pre>

<p>see also Go&rsquo;s implementation of quick sort in <a href="https://golang.org/src/sort/sort.go">sort package</a></p>

<p><div id="python"/></p>

<h2>Python</h2>

<p>Lomuto:</p>

<pre><code class="language-python">def partition(input_list, low_idx, high_idx):
    pivot_value = input_list[high_idx]
    i = low_idx

    for j in range(i, high_idx):
        if input_list[j] &lt;= pivot_value:
            input_list[i], input_list[j] = input_list[j], input_list[i]
            i = i + 1
    input_list[high_idx], input_list[i] = input_list[i], input_list[high_idx]
    return i


def _sort_range(input_list, low_idx, high_idx):
    if low_idx &gt;= high_idx:
        return

    partition_idx = partition(input_list, low_idx, high_idx)
    _sort_range(input_list, low_idx, partition_idx - 1)
    _sort_range(input_list, partition_idx + 1, high_idx)


def sort(input_list):
    if not input_list or len(input_list) &lt; 2:
        return
    _sort_range(input_list, 0, len(input_list) - 1)
</code></pre>

<p>Hoare:</p>

<pre><code class="language-python">def partition(input_list, low_idx, high_idx):
    pivot_value = input_list[low_idx]
    left_idx = low_idx
    right_idx = high_idx + 1

    while True:

        while True:
            left_idx = left_idx + 1
            if left_idx == high_idx or input_list[left_idx] &gt;= pivot_value:
                break

        while True:
            right_idx = right_idx - 1
            if right_idx == low_idx or input_list[right_idx] &lt;= pivot_value:
                break

        if left_idx &gt;= right_idx:
            break

        input_list[left_idx], input_list[right_idx] = input_list[right_idx], input_list[left_idx]

    input_list[low_idx], input_list[right_idx] = input_list[right_idx], input_list[low_idx]
    return right_idx


def _sort_range(input_list, low_idx, high_idx):
    if low_idx &gt;= high_idx:
        return

    partition_idx = partition(input_list, low_idx, high_idx)
    _sort_range(input_list, low_idx, partition_idx - 1)
    _sort_range(input_list, partition_idx + 1, high_idx)


def sort(input_list):
    if not input_list or len(input_list) &lt; 2:
        return
    _sort_range(input_list, 0, len(input_list) - 1)
</code></pre>

<p><div id="javascript"/></p>

<h2>JavaScript</h2>

<p>Lomuto:</p>

<pre><code class="language-javascript">function sort(arr, lowIdx = 0, highIdx = arr.length - 1) {
  if (!arr || lowIdx &gt;= highIdx || arr.length &lt; 2) return

  const partitionIdx = partition(arr, lowIdx, highIdx)
  sort(arr, lowIdx, partitionIdx - 1)
  sort(arr, partitionIdx + 1, highIdx)
}

function partition(arr, lowIdx, highIdx) {
  const pivotValue = arr[highIdx]
  let i = lowIdx

  for (j = i; j &lt; highIdx; j++) {
    if (arr[j] &lt;= pivotValue) {
      swap(arr, i, j)
      i++
    }
  }
  swap(arr, highIdx, i)
  return i
}

function swap(arr, i, j) {
  const tmp = arr[i]
  arr[i] = arr[j]
  arr[j] = tmp
}
</code></pre>

<p>Hoare:</p>

<pre><code class="language-javascript">function sort(arr, lowIdx = 0, highIdx = arr.length - 1) {
  if (!arr || lowIdx &gt;= highIdx || arr.length &lt; 2) return

  const partitionIdx = partition(arr, lowIdx, highIdx)
  sort(arr, lowIdx, partitionIdx - 1)
  sort(arr, partitionIdx + 1, highIdx)
}

function partition(arr, lowIdx, highIdx) {
  const pivotValue = arr[lowIdx]
  let leftIdx = lowIdx
  let rightIdx = highIdx + 1

  while(true) {
    do {
       leftIdx++;
       if (leftIdx == highIdx) {
         break;
       }
    } 
    while(arr[leftIdx] &lt; pivotValue);

    do {
      rightIdx--;
      if (rightIdx == lowIdx) {
        break;
      }
    }
    while (arr[rightIdx] &gt; pivotValue);

    if (leftIdx &gt;= rightIdx) {
      break;
    }
    swap(arr, leftIdx, rightIdx)
  }

  swap(arr, lowIdx, rightIdx)
  return rightIdx
}

function swap(arr, i, j) {
  const tmp = arr[i]
  arr[i] = arr[j]
  arr[j] = tmp
}
</code></pre>

<p><div id="kotlin"/></p>

<h2>Kotlin</h2>

<p>Lomuto:</p>

<pre><code class="language-kotlin">package sort

class LomutoQuickSort {
    companion object {
        fun &lt;T : Comparable&lt;in T&gt;&gt; sort(array: Array&lt;T&gt;, lowIdx: Int = 0, highIdx: Int = array.size - 1) {
            if (array.size &lt; 2 || lowIdx &gt;= highIdx) return

            val partitionIdx = partition(array, lowIdx, highIdx)
            sort(array, lowIdx, partitionIdx - 1)
            sort(array, partitionIdx + 1, highIdx)
        }

        private fun &lt;T : Comparable&lt;in T&gt;&gt; partition(array: Array&lt;T&gt;, lowIdx: Int, highIdx: Int): Int {
            val pivot = array[highIdx]
            var i = lowIdx

            for (j in i until highIdx) {
                if (array[j] &lt;= pivot) {
                    swap(array, i, j)
                    i++
                }
            }
            swap(array, highIdx, i)
            return i
        }

        private fun &lt;T&gt; swap(array: Array&lt;T&gt;, i: Int, j: Int) {
            val tmp = array[i]
            array[i] = array[j]
            array[j] = tmp
        }
    }
}

</code></pre>

<p>Hoare:</p>

<pre><code class="language-kotlin">package sort

class HoareQuickSort {
    companion object {
        fun &lt;T : Comparable&lt;in T&gt;&gt; sort(array: Array&lt;T&gt;, lowIdx: Int = 0, highIdx: Int = array.size - 1) {
            if (array.size &lt; 2 || lowIdx &gt;= highIdx) return

            val partitionIdx = partition(array, lowIdx, highIdx)
            sort(array, lowIdx, partitionIdx - 1)
            sort(array, partitionIdx + 1, highIdx)
        }

        private fun &lt;T : Comparable&lt;in T&gt;&gt; partition(array: Array&lt;T&gt;, lowIdx: Int, highIdx: Int): Int {
            val pivotValue = array[lowIdx]
            var leftIdx = lowIdx
            var rightIdx = highIdx + 1

            while (true) {
                do {
                    leftIdx++
                    if (leftIdx == highIdx) break
                } while (array[leftIdx] &lt; pivotValue)

                do {
                    rightIdx--
                    if (rightIdx == lowIdx) break
                } while (array[rightIdx] &gt; pivotValue)

                if (leftIdx &gt;= rightIdx) break

                swap(array, leftIdx, rightIdx)
            }

            swap(array, lowIdx, rightIdx)
            return rightIdx
        }

        private fun &lt;T&gt; swap(array: Array&lt;T&gt;, i: Int, j: Int) {
            val tmp = array[i]
            array[i] = array[j]
            array[j] = tmp
        }
    }
}
</code></pre>
 
    </div>

</div>


<script src="/static/js/prism.js"></script>
</body>
</html>

