
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    
    <meta name="description" content="Validate single parentheses algorithm">
    <meta name="keywords" content="learn, explain, tutorial, data structures, algorithms, graph, tree, interview, java, golang, kotlin, python, validate single parentheses">

    <title>  Validate single parentheses algorithm  | Practical algorithms and data structures </title>
    <link rel='stylesheet' href='/static/styles/styles.css'/>
    <link rel='stylesheet' href='/static/styles/prism.css'/>
</head>

<body>

<div class="rootContainer">

    <div class="horizontal-menu-box">
        
    <div class="menu">
    
    <div class="menuItem">
        
            <a href="/index.html" >
                ABOUT
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/fundamental.html" >
                FUNDAMENTAL
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/basic.html" >
                BASIC
            </a>
        
    </div>

     
     <div class="menuItem">
        
            <a href="/advanced.html" >
                ADVANCED
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/ninja.html" >
                NINJA
            </a>
        
    </div>

    
    <div class="menuItem">
        
            <a href="/languages.html" >
                LANGUAGES
            </a>
        
    </div>

</div>

    </div>

    <div class="content">
         <h1>Validate single parentheses</h1>

<h2>Contents</h2>

<hr />

<ul>
<li><a href="#description">Description</a></li>
<li><a href="#complexity">Complexity</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#go">Go</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#kotlin">Kotlin</a></li>
</ul>

<hr />

<p><div id="description"/></p>

<h2>Description</h2>

<p>Unlike <a href="/validate-multiple-parentheses.html">multiple parentheses</a>, single parentheses validation doesn&rsquo;t require <code>Stack</code> data structure.</p>

<p>Using simple counter is enough:</p>

<ul>
<li>for open parenthesis, like <code>(</code>, <strong>increment counter</strong></li>
<li>for close parenthesis, like <code>)</code>, <strong>decrement counter</strong></li>
</ul>

<p>To avoid invalid cases like <code>)(</code> or <code>())(</code> check if <code>counter == 0</code>, if so - return <code>false</code></p>

<p>After checking each character return <code>true</code> if <code>counter == 0</code>, otherwise return <code>false</code></p>

<p><div id="complexity"/></p>

<h2>Complexity</h2>

<p><code>O(N)</code></p>

<p><div id="java"/></p>

<h2>Java</h2>

<pre><code class="language-java">package arrays;

public class JavaSingleParenthesesValidator {
    private final char open;
    private final char close;
    private int counter;

    public JavaSingleParenthesesValidator(char open, char close) {
        this.open = open;
        this.close = close;
    }

    public boolean validate(String str) {
        if (str == null || str.isEmpty()) return false;

        char[] chars = str.toCharArray();

        for (int i = 0; i &lt; chars.length; i++) {
            char curChar = chars[i];
            if (curChar == open) {
                counter++;
            } else if (curChar == close) {
                if (counter == 0) return false;

                counter--;
            }
        }
        return counter == 0;
    }
}
</code></pre>

<p>Test:</p>

<pre><code class="language-java">package arrays;


import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class JavaSingleParenthesesValidatorTest {

    @Test
    public void validateCorrect() {
        // given
        JavaSingleParenthesesValidator validator = new JavaSingleParenthesesValidator('(', ')');

        // when
        boolean actual = validator.validate(&quot;to ((be)) or (not) to be&quot;);

        // then
        assertTrue(actual);
    }

    @Test
    public void validateIncorrect() {
        // given
        JavaSingleParenthesesValidator validator = new JavaSingleParenthesesValidator('(', ')');

        // when
        boolean actual = validator.validate(&quot;to ((be)(or) not&quot;);

        // then
        assertFalse(actual);
    }

    @Test
    public void startsClosedShouldFail() {
        // given
        JavaSingleParenthesesValidator validator = new JavaSingleParenthesesValidator('(', ')');

        // when
        boolean actual = validator.validate(&quot;)(&quot;);

        // then
        assertFalse(actual);
    }

    @Test
    public void notValidClosedPositionInTheMiddle() {
        // given
        JavaSingleParenthesesValidator validator = new JavaSingleParenthesesValidator('(', ')');

        // when
        boolean actual = validator.validate(&quot;to (be)) or (&quot;);

        // then
        assertFalse(actual);
    }

}
</code></pre>

<p><div id="go"/></p>

<h2>Go</h2>

<pre><code class="language-go">package arrays

func validate(open rune, close rune, str string) bool {
	counter := 0
	runes := []rune(str)
	for _, rune := range runes {
		if rune == open {
			counter++
		} else if rune == close {
			if counter == 0 {
				return false
			}
			counter--
		}
	}
	return counter == 0
}
</code></pre>

<p>Test:</p>

<pre><code class="language-go">package arrays

import &quot;testing&quot;

func Test_validate(t *testing.T) {
	type args struct {
		open  rune
		close rune
		str   string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{&quot;valid case&quot;, args{rune('('), rune(')'), &quot;to ((be)) or (not) to be&quot;}, true},
		{&quot;not valid case&quot;, args{rune('('), rune(')'), &quot;to ((be)(or) not&quot;}, false},
		{&quot;should not start with closed&quot;, args{rune('('), rune(')'), &quot;)(&quot;}, false},
		{&quot;not valid closed at the end&quot;, args{rune('('), rune(')'), &quot;to (be)) or (&quot;}, false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := validate(tt.args.open, tt.args.close, tt.args.str); got != tt.want {
				t.Errorf(&quot;validate() = %v, want %v&quot;, got, tt.want)
			}
		})
	}
}
</code></pre>

<p><div id="python"/></p>

<h2>Python</h2>

<pre><code class="language-python">def validate(input_str, open_str=&quot;(&quot;, closed_str=&quot;)&quot;):
    counter = 0
    for c in input_str:
        if c == open_str:
            counter = counter + 1
        elif c == closed_str:
            if counter == 0:
                return False
            counter = counter - 1
    return counter == 0


def test_validation():
    assert (validate(&quot;to ((be)) or (not) to be&quot;)), &quot;should be valid&quot;
    assert (not validate(&quot;to ((be)(or) not&quot;)), &quot;should be not valid&quot;
    assert (not validate(&quot;)(&quot;)), &quot;should be not valid&quot;
    assert (not validate(&quot;to (be)) or (&quot;)), &quot;should be not valid&quot;


if __name__ == &quot;__main__&quot;:
    test_validation()

</code></pre>

<p><div id="javascript"/></p>

<h2>JavaScript</h2>

<pre><code class="language-javascript">function validate(open, closed, str) {
  let counter = 0
  for (i=0; i &lt; str.length; i++) {
    let c = str.charAt(i)
    if (c == open) {
      counter++
    } else if (c == closed) {
      if (counter == 0) return false
      counter--
    }
  }
  return counter == 0
}

console.log(validate(&quot;(&quot;, &quot;)&quot;, &quot;to ((be)) or (not) to be&quot;)) // true
console.log(validate(&quot;(&quot;, &quot;)&quot;, &quot;to ((be)(or) not&quot;)) // false
console.log(validate(&quot;(&quot;, &quot;)&quot;, &quot;)(&quot;)) // false
console.log(validate(&quot;(&quot;, &quot;)&quot;, &quot;to (be)) or (&quot;)) // false

</code></pre>

<p><div id="kotlin"/></p>

<h2>Kotlin</h2>

<pre><code class="language-kotlin">package arrays

class SingleParenthesesValidator(val open: Char, val closed: Char) {

    fun validate(str: String): Boolean {
        var counter = 0
        if (str.isBlank()) return false;

        for (i in 0 until str.length) {
            val char = str[i]
            if (char == open) {
                counter++
            } else if (char == closed) {
                if (counter == 0) return false
                counter--
            }
        }
        return counter == 0
    }
}
</code></pre>

<p>Test:</p>

<pre><code class="language-kotlin">package arrays

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

internal class SingleParenthesesValidatorTest {

    @Test
    fun validateCorrect() {
        // given
        val validator = SingleParenthesesValidator('(', ')')

        // when
        val actual = validator.validate(&quot;to ((be)) or (not) to be&quot;)

        // then
        assertTrue(actual)
    }

    @Test
    fun validateIncorrect() {
        // given
        val validator = SingleParenthesesValidator('(', ')')

        // when
        val actual = validator.validate(&quot;to ((be)(or) not&quot;)

        // then
        assertFalse(actual)
    }

    @Test
    fun startsClosedShouldFail() {
        // given
        val validator = SingleParenthesesValidator('(', ')')

        // when
        val actual = validator.validate(&quot;)(&quot;)

        // then
        assertFalse(actual)
    }

    @Test
    fun notValidClosedPositionInTheMiddle() {
        // given
        val validator = SingleParenthesesValidator('(', ')')

        // when
        val actual = validator.validate(&quot;to (be)) or (&quot;)

        // then
        assertFalse(actual)
    }
}

</code></pre>
 
    </div>

</div>


<script src="/static/js/prism.js"></script>
</body>
</html>

